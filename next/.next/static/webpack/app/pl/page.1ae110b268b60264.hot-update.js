"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/pl/page",{

/***/ "(app-pages-browser)/./src/lib/statements/parser.ts":
/*!**************************************!*\
  !*** ./src/lib/statements/parser.ts ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   categorizeTransaction: function() { return /* binding */ categorizeTransaction; },\n/* harmony export */   detectProvider: function() { return /* binding */ detectProvider; },\n/* harmony export */   parseAmount: function() { return /* binding */ parseAmount; },\n/* harmony export */   parseBNPRow: function() { return /* binding */ parseBNPRow; },\n/* harmony export */   parseBoursoramaRow: function() { return /* binding */ parseBoursoramaRow; },\n/* harmony export */   parseCSV: function() { return /* binding */ parseCSV; },\n/* harmony export */   parseCSVWithDelimiter: function() { return /* binding */ parseCSVWithDelimiter; },\n/* harmony export */   parseDate: function() { return /* binding */ parseDate; },\n/* harmony export */   parseFiles: function() { return /* binding */ parseFiles; },\n/* harmony export */   parseRevolutRow: function() { return /* binding */ parseRevolutRow; }\n/* harmony export */ });\n// CSV parsing with delimiter detection and BOM handling\nfunction parseCSVWithDelimiter(text, delimiter) {\n    const rows = [];\n    let cur = \"\";\n    let row = [];\n    let inQuotes = false;\n    for(let i = 0; i < text.length; i++){\n        const c = text[i];\n        const next = text[i + 1];\n        if (inQuotes) {\n            if (c === '\"' && next === '\"') {\n                cur += '\"';\n                i++;\n            } else if (c === '\"') {\n                inQuotes = false;\n            } else {\n                cur += c;\n            }\n        } else {\n            if (c === '\"') {\n                inQuotes = true;\n            } else if (c === delimiter) {\n                row.push(cur);\n                cur = \"\";\n            } else if (c === \"\\n\") {\n                row.push(cur);\n                rows.push(row);\n                row = [];\n                cur = \"\";\n            } else if (c === \"\\r\") {\n            // ignore\n            } else {\n                cur += c;\n            }\n        }\n    }\n    if (cur.length > 0 || row.length > 0) {\n        row.push(cur);\n        rows.push(row);\n    }\n    // Clean BOM and trim cells\n    if (rows.length && rows[0].length) {\n        rows[0][0] = rows[0][0].replace(/^\\ufeff/, \"\");\n    }\n    for(let r = 0; r < rows.length; r++){\n        rows[r] = rows[r].map((v)=>v == null ? \"\" : String(v).trim());\n    }\n    return rows;\n}\nfunction parseCSV(text) {\n    const candidates = [\n        \",\",\n        \";\",\n        \"\t\"\n    ];\n    let best = null;\n    let bestScore = -1;\n    for (const d of candidates){\n        const rows = parseCSVWithDelimiter(text, d);\n        let count = 0, cols = 0;\n        for (const r of rows){\n            const nonEmpty = r.filter((x)=>x && x.trim() !== \"\").length;\n            if (nonEmpty > 1) {\n                cols += r.length;\n                count++;\n            }\n            if (count >= 5) break;\n        }\n        const score = count ? cols / count : 0;\n        if (score > bestScore) {\n            bestScore = score;\n            best = rows;\n        }\n    }\n    return best || [\n        []\n    ];\n}\nfunction detectProvider(rows) {\n    for(let i = 0; i < Math.min(5, rows.length); i++){\n        const headerStr = rows[i].join(\" \").toLowerCase();\n        if (headerStr.includes(\"dateop\") || headerStr.includes(\"dateval\") || headerStr.includes(\"categoryparent\") || headerStr.includes(\"accountlabel\")) {\n            return {\n                provider: \"boursorama\",\n                headerRow: i\n            };\n        }\n        if (headerStr.includes(\"date operation\") || headerStr.includes(\"categorie operation\") || headerStr.includes(\"libelle operation\") || headerStr.includes(\"montant operation\")) {\n            return {\n                provider: \"bnp\",\n                headerRow: i\n            };\n        }\n        if (headerStr.includes(\"started date\") || headerStr.includes(\"completed date\") || headerStr.includes(\"type\") && headerStr.includes(\"product\") && headerStr.includes(\"amount\")) {\n            return {\n                provider: \"revolut\",\n                headerRow: i\n            };\n        }\n    }\n    return {\n        provider: \"unknown\",\n        headerRow: 0\n    };\n}\nfunction parseDate(dateStr, provider) {\n    if (!dateStr) return null;\n    if (provider === \"boursorama\") {\n        const match = dateStr.match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n        if (match) return \"\".concat(match[1], \"-\").concat(match[2], \"-\").concat(match[3]);\n    } else if (provider === \"revolut\") {\n        const match = dateStr.match(/(\\d{4})-(\\d{2})-(\\d{2})/);\n        if (match) return \"\".concat(match[1], \"-\").concat(match[2], \"-\").concat(match[3]);\n    } else if (provider === \"bnp\") {\n        const match = dateStr.match(/(\\d{2})-(\\d{2})-(\\d{4})/);\n        if (match) return \"\".concat(match[3], \"-\").concat(match[2], \"-\").concat(match[1]);\n    } else {\n        const match = dateStr.match(/(\\d{2})\\/(\\d{2})\\/(\\d{4})/);\n        if (match) return \"\".concat(match[3], \"-\").concat(match[2], \"-\").concat(match[1]);\n    }\n    return null;\n}\nfunction parseAmount(v) {\n    if (typeof v === \"number\") return v;\n    if (v == null) return 0;\n    let s = String(v).trim();\n    if (!s) return 0;\n    s = s.replace(/\\s/g, \"\");\n    if (s.includes(\",\")) {\n        if (s.indexOf(\".\") < s.indexOf(\",\")) {\n            s = s.replace(/\\./g, \"\").replace(\",\", \".\");\n        } else {\n            s = s.replace(\",\", \".\");\n        }\n    }\n    s = s.replace(/[^\\d.-]/g, \"\");\n    const n = parseFloat(s);\n    return isNaN(n) ? 0 : n;\n}\nfunction categorizeTransaction(description, rulesText) {\n    const desc = (description || \"\").toLowerCase();\n    const categories = {\n        \"Transport\": [\n            \"sncf\",\n            \"ratp\",\n            \"uber\",\n            \"taxi\",\n            \"metro\",\n            \"bus\",\n            \"train\"\n        ],\n        \"E-commerce\": [\n            \"amazon\",\n            \"cdiscount\",\n            \"fnac\",\n            \"ebay\",\n            \"aliexpress\"\n        ],\n        \"Food & Restaurants\": [\n            \"carrefour\",\n            \"franprix\",\n            \"monoprix\",\n            \"auchan\",\n            \"restaurant\",\n            \"cafe\",\n            \"boulangerie\"\n        ],\n        \"Utilities\": [\n            \"edf\",\n            \"orange\",\n            \"sfr\",\n            \"free\",\n            \"bouygues\",\n            \"internet\",\n            \"mobile\"\n        ],\n        \"Health\": [\n            \"pharmacy\",\n            \"pharmacie\",\n            \"doctor\",\n            \"docteur\",\n            \"medical\",\n            \"hopital\"\n        ],\n        \"Accommodation\": [\n            \"airbnb\",\n            \"hotel\",\n            \"booking\",\n            \"loyer\",\n            \"rent\"\n        ],\n        \"Entertainment\": [\n            \"cinema\",\n            \"netflix\",\n            \"spotify\",\n            \"steam\",\n            \"playstation\",\n            \"xbox\"\n        ]\n    };\n    if (rulesText) {\n        const lines = rulesText.split(\"\\n\");\n        for (const line of lines){\n            const [keyword, category] = line.split(\"=\").map((s)=>{\n                var _s_trim;\n                return (_s_trim = s === null || s === void 0 ? void 0 : s.trim()) !== null && _s_trim !== void 0 ? _s_trim : \"\";\n            });\n            if (keyword && category && desc.includes(keyword.toLowerCase())) return category;\n        }\n    }\n    for (const [category, keywords] of Object.entries(categories)){\n        for (const keyword of keywords){\n            if (desc.includes(keyword)) return category;\n        }\n    }\n    return \"Other\";\n}\nfunction parseBoursoramaRow(row, headers, accountLabel, rulesText) {\n    const dateIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"dateop\"));\n    const descIdx = headers.findIndex((h)=>h.toLowerCase() === \"label\" || h.toLowerCase().includes(\"label\"));\n    const amountIdx = headers.findIndex((h)=>h.toLowerCase() === \"amount\");\n    const categoryIdx = headers.findIndex((h)=>h.toLowerCase() === \"categoryparent\" || h.toLowerCase().includes(\"categoryparent\"));\n    const accountIdx = headers.findIndex((h)=>h.toLowerCase() === \"accountlabel\" || h.toLowerCase().includes(\"accountlabel\"));\n    const balIdx = headers.findIndex((h)=>h.toLowerCase() === \"accountbalance\" || h.toLowerCase().includes(\"accountbalance\"));\n    if (dateIdx === -1 || descIdx === -1 || amountIdx === -1) return null;\n    const date = parseDate(row[dateIdx], \"boursorama\");\n    const description = row[descIdx] || \"\";\n    const amount = parseAmount(row[amountIdx]);\n    const category = row[categoryIdx] || categorizeTransaction(description, rulesText);\n    const account = accountIdx !== -1 ? row[accountIdx] || accountLabel : accountLabel;\n    const balance = balIdx !== -1 ? parseAmount(row[balIdx]) : undefined;\n    return {\n        date: date || \"\",\n        description,\n        amount,\n        currency: \"EUR\",\n        category,\n        account,\n        provider: \"boursorama\",\n        balance,\n        balanceCurrency: balance == null ? undefined : \"EUR\",\n        originalAmount: amount,\n        originalCurrency: \"EUR\"\n    };\n}\nfunction parseBNPRow(row, headers, accountLabel, rulesText) {\n    const dateIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"date\"));\n    const descIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"libelle\"));\n    const amountIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"montant\"));\n    const categoryIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"categorie\") && !h.toLowerCase().includes(\"sous\"));\n    if (dateIdx === -1 || descIdx === -1 || amountIdx === -1) return null;\n    const date = parseDate(row[dateIdx], \"bnp\");\n    const description = row[descIdx] || \"\";\n    const amount = parseAmount(row[amountIdx]);\n    const bnpCategory = row[categoryIdx] || \"\";\n    const category = bnpCategory || categorizeTransaction(description, rulesText);\n    return {\n        date: date || \"\",\n        description,\n        amount,\n        currency: \"EUR\",\n        category,\n        account: accountLabel,\n        provider: \"bnp\",\n        originalAmount: amount,\n        originalCurrency: \"EUR\"\n    };\n}\nfunction parseRevolutRow(row, headers, accountLabel, gbpToEurRate, rulesText) {\n    const startedIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"started\"));\n    const completedIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"completed\"));\n    const descIdx = headers.findIndex((h)=>h.toLowerCase().includes(\"description\"));\n    const amountIdx = headers.findIndex((h)=>h.toLowerCase() === \"amount\" || h.toLowerCase().includes(\"amount\"));\n    const currencyIdx = headers.findIndex((h)=>h.toLowerCase() === \"currency\" || h.toLowerCase().includes(\"currency\"));\n    const balIdx = headers.findIndex((h)=>h.toLowerCase() === \"balance\" || h.toLowerCase().includes(\"balance\"));\n    if (startedIdx === -1 && completedIdx === -1 || descIdx === -1 || amountIdx === -1) return null;\n    const dateRaw = startedIdx !== -1 ? row[startedIdx] : row[completedIdx];\n    const date = parseDate(dateRaw, \"revolut\");\n    const description = row[descIdx] || \"\";\n    const amountRaw = parseAmount(row[amountIdx]);\n    const currency = (currencyIdx !== -1 ? row[currencyIdx] : \"EUR\") || \"EUR\";\n    const amountEUR = currency.toUpperCase() === \"GBP\" ? amountRaw * gbpToEurRate : amountRaw;\n    const category = categorizeTransaction(description, rulesText);\n    const rawBalance = balIdx !== -1 ? parseAmount(row[balIdx]) : undefined;\n    return {\n        date: date || \"\",\n        description,\n        amount: amountEUR,\n        currency: \"EUR\",\n        category,\n        account: accountLabel,\n        provider: \"revolut\",\n        balance: rawBalance,\n        balanceCurrency: rawBalance == null ? undefined : currency || \"GBP\",\n        originalAmount: amountRaw,\n        originalCurrency: currency || \"GBP\"\n    };\n}\nasync function parseFiles(files, gbpToEurRate, rulesText) {\n    const all = [];\n    const entries = Object.entries(files);\n    for (const [bank, file] of entries){\n        if (!file) continue;\n        const text = await file.text();\n        const rows = parseCSV(text);\n        if (rows.length < 2) continue;\n        const { provider, headerRow } = detectProvider(rows);\n        const headers = rows[headerRow];\n        for(let i = headerRow + 1; i < rows.length; i++){\n            const row = rows[i];\n            if (row.length < 3) continue;\n            if (row.every((cell)=>!cell || cell.trim() === \"\")) continue;\n            let t = null;\n            if (provider === \"boursorama\") {\n                let defaultLabel = \"Boursorama\";\n                if (bank === \"boursoramaPersonal\") defaultLabel = \"BoursoBank\";\n                else if (bank === \"boursoramaJoint\") defaultLabel = \"BoursoBank (joint)\";\n                t = parseBoursoramaRow(row, headers, defaultLabel, rulesText);\n            } else if (provider === \"bnp\") t = parseBNPRow(row, headers, \"BNP\", rulesText);\n            else if (provider === \"revolut\") t = parseRevolutRow(row, headers, \"Revolut\", gbpToEurRate, rulesText);\n            if (t && t.date && t.amount !== 0) all.push(t);\n        }\n    }\n    all.sort((a, b)=>b.date.localeCompare(a.date));\n    return all;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc3RhdGVtZW50cy9wYXJzZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUVBLHdEQUF3RDtBQUNqRCxTQUFTQSxzQkFBc0JDLElBQVksRUFBRUMsU0FBaUI7SUFDbkUsTUFBTUMsT0FBbUIsRUFBRTtJQUMzQixJQUFJQyxNQUFNO0lBQ1YsSUFBSUMsTUFBZ0IsRUFBRTtJQUN0QixJQUFJQyxXQUFXO0lBRWYsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLEtBQUtPLE1BQU0sRUFBRUQsSUFBSztRQUNwQyxNQUFNRSxJQUFJUixJQUFJLENBQUNNLEVBQUU7UUFDakIsTUFBTUcsT0FBT1QsSUFBSSxDQUFDTSxJQUFJLEVBQUU7UUFFeEIsSUFBSUQsVUFBVTtZQUNaLElBQUlHLE1BQU0sT0FBT0MsU0FBUyxLQUFLO2dCQUM3Qk4sT0FBTztnQkFDUEc7WUFDRixPQUFPLElBQUlFLE1BQU0sS0FBSztnQkFDcEJILFdBQVc7WUFDYixPQUFPO2dCQUNMRixPQUFPSztZQUNUO1FBQ0YsT0FBTztZQUNMLElBQUlBLE1BQU0sS0FBSztnQkFDYkgsV0FBVztZQUNiLE9BQU8sSUFBSUcsTUFBTVAsV0FBVztnQkFDMUJHLElBQUlNLElBQUksQ0FBQ1A7Z0JBQ1RBLE1BQU07WUFDUixPQUFPLElBQUlLLE1BQU0sTUFBTTtnQkFDckJKLElBQUlNLElBQUksQ0FBQ1A7Z0JBQ1RELEtBQUtRLElBQUksQ0FBQ047Z0JBQ1ZBLE1BQU0sRUFBRTtnQkFDUkQsTUFBTTtZQUNSLE9BQU8sSUFBSUssTUFBTSxNQUFNO1lBQ3JCLFNBQVM7WUFDWCxPQUFPO2dCQUNMTCxPQUFPSztZQUNUO1FBQ0Y7SUFDRjtJQUVBLElBQUlMLElBQUlJLE1BQU0sR0FBRyxLQUFLSCxJQUFJRyxNQUFNLEdBQUcsR0FBRztRQUNwQ0gsSUFBSU0sSUFBSSxDQUFDUDtRQUNURCxLQUFLUSxJQUFJLENBQUNOO0lBQ1o7SUFFQSwyQkFBMkI7SUFDM0IsSUFBSUYsS0FBS0ssTUFBTSxJQUFJTCxJQUFJLENBQUMsRUFBRSxDQUFDSyxNQUFNLEVBQUU7UUFDakNMLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHQSxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQ1MsT0FBTyxDQUFDLFdBQVc7SUFDN0M7SUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVYsS0FBS0ssTUFBTSxFQUFFSyxJQUFLO1FBQ3BDVixJQUFJLENBQUNVLEVBQUUsR0FBR1YsSUFBSSxDQUFDVSxFQUFFLENBQUNDLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBTUEsS0FBSyxPQUFPLEtBQUtDLE9BQU9ELEdBQUdFLElBQUk7SUFDN0Q7SUFDQSxPQUFPZDtBQUNUO0FBRU8sU0FBU2UsU0FBU2pCLElBQVk7SUFDbkMsTUFBTWtCLGFBQWE7UUFBQztRQUFLO1FBQUs7S0FBSztJQUNuQyxJQUFJQyxPQUEwQjtJQUM5QixJQUFJQyxZQUFZLENBQUM7SUFFakIsS0FBSyxNQUFNQyxLQUFLSCxXQUFZO1FBQzFCLE1BQU1oQixPQUFPSCxzQkFBc0JDLE1BQU1xQjtRQUN6QyxJQUFJQyxRQUFRLEdBQUdDLE9BQU87UUFDdEIsS0FBSyxNQUFNWCxLQUFLVixLQUFNO1lBQ3BCLE1BQU1zQixXQUFXWixFQUFFYSxNQUFNLENBQUNDLENBQUFBLElBQUtBLEtBQUtBLEVBQUVWLElBQUksT0FBTyxJQUFJVCxNQUFNO1lBQzNELElBQUlpQixXQUFXLEdBQUc7Z0JBQ2hCRCxRQUFRWCxFQUFFTCxNQUFNO2dCQUNoQmU7WUFDRjtZQUNBLElBQUlBLFNBQVMsR0FBRztRQUNsQjtRQUNBLE1BQU1LLFFBQVFMLFFBQVFDLE9BQU9ELFFBQVE7UUFDckMsSUFBSUssUUFBUVAsV0FBVztZQUNyQkEsWUFBWU87WUFDWlIsT0FBT2pCO1FBQ1Q7SUFDRjtJQUVBLE9BQU9pQixRQUFRO1FBQUMsRUFBRTtLQUFDO0FBQ3JCO0FBRU8sU0FBU1MsZUFBZTFCLElBQWdCO0lBQzdDLElBQUssSUFBSUksSUFBSSxHQUFHQSxJQUFJdUIsS0FBS0MsR0FBRyxDQUFDLEdBQUc1QixLQUFLSyxNQUFNLEdBQUdELElBQUs7UUFDakQsTUFBTXlCLFlBQVk3QixJQUFJLENBQUNJLEVBQUUsQ0FBQzBCLElBQUksQ0FBQyxLQUFLQyxXQUFXO1FBQy9DLElBQ0VGLFVBQVVHLFFBQVEsQ0FBQyxhQUFhSCxVQUFVRyxRQUFRLENBQUMsY0FDbkRILFVBQVVHLFFBQVEsQ0FBQyxxQkFBcUJILFVBQVVHLFFBQVEsQ0FBQyxpQkFDM0Q7WUFDQSxPQUFPO2dCQUFFQyxVQUFVO2dCQUFjQyxXQUFXOUI7WUFBRTtRQUNoRDtRQUNBLElBQ0V5QixVQUFVRyxRQUFRLENBQUMscUJBQXFCSCxVQUFVRyxRQUFRLENBQUMsMEJBQzNESCxVQUFVRyxRQUFRLENBQUMsd0JBQXdCSCxVQUFVRyxRQUFRLENBQUMsc0JBQzlEO1lBQ0EsT0FBTztnQkFBRUMsVUFBVTtnQkFBT0MsV0FBVzlCO1lBQUU7UUFDekM7UUFDQSxJQUNFeUIsVUFBVUcsUUFBUSxDQUFDLG1CQUFtQkgsVUFBVUcsUUFBUSxDQUFDLHFCQUN4REgsVUFBVUcsUUFBUSxDQUFDLFdBQVdILFVBQVVHLFFBQVEsQ0FBQyxjQUFjSCxVQUFVRyxRQUFRLENBQUMsV0FDbkY7WUFDQSxPQUFPO2dCQUFFQyxVQUFVO2dCQUFXQyxXQUFXOUI7WUFBRTtRQUM3QztJQUNGO0lBQ0EsT0FBTztRQUFFNkIsVUFBVTtRQUFXQyxXQUFXO0lBQUU7QUFDN0M7QUFFTyxTQUFTQyxVQUFVQyxPQUFlLEVBQUVILFFBQWlDO0lBQzFFLElBQUksQ0FBQ0csU0FBUyxPQUFPO0lBQ3JCLElBQUlILGFBQWEsY0FBYztRQUM3QixNQUFNSSxRQUFRRCxRQUFRQyxLQUFLLENBQUM7UUFDNUIsSUFBSUEsT0FBTyxPQUFPLEdBQWVBLE9BQVpBLEtBQUssQ0FBQyxFQUFFLEVBQUMsS0FBZUEsT0FBWkEsS0FBSyxDQUFDLEVBQUUsRUFBQyxLQUFZLE9BQVRBLEtBQUssQ0FBQyxFQUFFO0lBQ3ZELE9BQU8sSUFBSUosYUFBYSxXQUFXO1FBQ2pDLE1BQU1JLFFBQVFELFFBQVFDLEtBQUssQ0FBQztRQUM1QixJQUFJQSxPQUFPLE9BQU8sR0FBZUEsT0FBWkEsS0FBSyxDQUFDLEVBQUUsRUFBQyxLQUFlQSxPQUFaQSxLQUFLLENBQUMsRUFBRSxFQUFDLEtBQVksT0FBVEEsS0FBSyxDQUFDLEVBQUU7SUFDdkQsT0FBTyxJQUFJSixhQUFhLE9BQU87UUFDN0IsTUFBTUksUUFBUUQsUUFBUUMsS0FBSyxDQUFDO1FBQzVCLElBQUlBLE9BQU8sT0FBTyxHQUFlQSxPQUFaQSxLQUFLLENBQUMsRUFBRSxFQUFDLEtBQWVBLE9BQVpBLEtBQUssQ0FBQyxFQUFFLEVBQUMsS0FBWSxPQUFUQSxLQUFLLENBQUMsRUFBRTtJQUN2RCxPQUFPO1FBQ0wsTUFBTUEsUUFBUUQsUUFBUUMsS0FBSyxDQUFDO1FBQzVCLElBQUlBLE9BQU8sT0FBTyxHQUFlQSxPQUFaQSxLQUFLLENBQUMsRUFBRSxFQUFDLEtBQWVBLE9BQVpBLEtBQUssQ0FBQyxFQUFFLEVBQUMsS0FBWSxPQUFUQSxLQUFLLENBQUMsRUFBRTtJQUN2RDtJQUNBLE9BQU87QUFDVDtBQUVPLFNBQVNDLFlBQVkxQixDQUFVO0lBQ3BDLElBQUksT0FBT0EsTUFBTSxVQUFVLE9BQU9BO0lBQ2xDLElBQUlBLEtBQUssTUFBTSxPQUFPO0lBQ3RCLElBQUkyQixJQUFJMUIsT0FBT0QsR0FBR0UsSUFBSTtJQUN0QixJQUFJLENBQUN5QixHQUFHLE9BQU87SUFDZkEsSUFBSUEsRUFBRTlCLE9BQU8sQ0FBQyxPQUFPO0lBQ3JCLElBQUk4QixFQUFFUCxRQUFRLENBQUMsTUFBTTtRQUNuQixJQUFJTyxFQUFFQyxPQUFPLENBQUMsT0FBT0QsRUFBRUMsT0FBTyxDQUFDLE1BQU07WUFDbkNELElBQUlBLEVBQUU5QixPQUFPLENBQUMsT0FBTyxJQUFJQSxPQUFPLENBQUMsS0FBSztRQUN4QyxPQUFPO1lBQ0w4QixJQUFJQSxFQUFFOUIsT0FBTyxDQUFDLEtBQUs7UUFDckI7SUFDRjtJQUNBOEIsSUFBSUEsRUFBRTlCLE9BQU8sQ0FBQyxZQUFZO0lBQzFCLE1BQU1nQyxJQUFJQyxXQUFXSDtJQUNyQixPQUFPSSxNQUFNRixLQUFLLElBQUlBO0FBQ3hCO0FBRU8sU0FBU0csc0JBQXNCQyxXQUFtQixFQUFFQyxTQUFrQjtJQUMzRSxNQUFNQyxPQUFPLENBQUNGLGVBQWUsRUFBQyxFQUFHZCxXQUFXO0lBQzVDLE1BQU1pQixhQUF1QztRQUMzQyxhQUFhO1lBQUM7WUFBUTtZQUFRO1lBQVE7WUFBUTtZQUFTO1lBQU87U0FBUTtRQUN0RSxjQUFjO1lBQUM7WUFBVTtZQUFhO1lBQVE7WUFBUTtTQUFhO1FBQ25FLHNCQUFzQjtZQUFDO1lBQWE7WUFBWTtZQUFZO1lBQVU7WUFBYztZQUFRO1NBQWM7UUFDMUcsYUFBYTtZQUFDO1lBQU87WUFBVTtZQUFPO1lBQVE7WUFBWTtZQUFZO1NBQVM7UUFDL0UsVUFBVTtZQUFDO1lBQVk7WUFBYTtZQUFVO1lBQVc7WUFBVztTQUFVO1FBQzlFLGlCQUFpQjtZQUFDO1lBQVU7WUFBUztZQUFXO1lBQVM7U0FBTztRQUNoRSxpQkFBaUI7WUFBQztZQUFVO1lBQVc7WUFBVztZQUFTO1lBQWU7U0FBTztJQUNuRjtJQUNBLElBQUlGLFdBQVc7UUFDYixNQUFNRyxRQUFRSCxVQUFVSSxLQUFLLENBQUM7UUFDOUIsS0FBSyxNQUFNQyxRQUFRRixNQUFPO1lBQ3hCLE1BQU0sQ0FBQ0csU0FBU0MsU0FBUyxHQUFHRixLQUFLRCxLQUFLLENBQUMsS0FBS3ZDLEdBQUcsQ0FBQzRCLENBQUFBO29CQUFLQTt1QkFBQUEsQ0FBQUEsVUFBQUEsY0FBQUEsd0JBQUFBLEVBQUd6QixJQUFJLGdCQUFQeUIscUJBQUFBLFVBQWE7WUFBQztZQUNuRSxJQUFJYSxXQUFXQyxZQUFZTixLQUFLZixRQUFRLENBQUNvQixRQUFRckIsV0FBVyxLQUFLLE9BQU9zQjtRQUMxRTtJQUNGO0lBQ0EsS0FBSyxNQUFNLENBQUNBLFVBQVVDLFNBQVMsSUFBSUMsT0FBT0MsT0FBTyxDQUFDUixZQUFhO1FBQzdELEtBQUssTUFBTUksV0FBV0UsU0FBVTtZQUM5QixJQUFJUCxLQUFLZixRQUFRLENBQUNvQixVQUFVLE9BQU9DO1FBQ3JDO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTSSxtQkFBbUJ2RCxHQUFhLEVBQUV3RCxPQUFpQixFQUFFQyxZQUFvQixFQUFFYixTQUFrQjtJQUMzRyxNQUFNYyxVQUFVRixRQUFRRyxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUNoRSxNQUFNK0IsVUFBVUwsUUFBUUcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0IsV0FBVyxPQUFPLFdBQVcrQixFQUFFL0IsV0FBVyxHQUFHQyxRQUFRLENBQUM7SUFDL0YsTUFBTWdDLFlBQVlOLFFBQVFHLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRS9CLFdBQVcsT0FBTztJQUM3RCxNQUFNa0MsY0FBY1AsUUFBUUcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0IsV0FBVyxPQUFPLG9CQUFvQitCLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUM1RyxNQUFNa0MsYUFBYVIsUUFBUUcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0IsV0FBVyxPQUFPLGtCQUFrQitCLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUN6RyxNQUFNbUMsU0FBU1QsUUFBUUcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0IsV0FBVyxPQUFPLG9CQUFvQitCLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUN2RyxJQUFJNEIsWUFBWSxDQUFDLEtBQUtHLFlBQVksQ0FBQyxLQUFLQyxjQUFjLENBQUMsR0FBRyxPQUFPO0lBQ2pFLE1BQU1JLE9BQU9qQyxVQUFVakMsR0FBRyxDQUFDMEQsUUFBUSxFQUFFO0lBQ3JDLE1BQU1mLGNBQWMzQyxHQUFHLENBQUM2RCxRQUFRLElBQUk7SUFDcEMsTUFBTU0sU0FBUy9CLFlBQVlwQyxHQUFHLENBQUM4RCxVQUFVO0lBQ3pDLE1BQU1YLFdBQVduRCxHQUFHLENBQUMrRCxZQUFZLElBQUlyQixzQkFBc0JDLGFBQWFDO0lBQ3hFLE1BQU13QixVQUFVSixlQUFlLENBQUMsSUFBS2hFLEdBQUcsQ0FBQ2dFLFdBQVcsSUFBSVAsZUFBZ0JBO0lBQ3hFLE1BQU1ZLFVBQVVKLFdBQVcsQ0FBQyxJQUFJN0IsWUFBWXBDLEdBQUcsQ0FBQ2lFLE9BQU8sSUFBSUs7SUFDM0QsT0FBTztRQUFFSixNQUFNQSxRQUFRO1FBQUl2QjtRQUFhd0I7UUFBUUksVUFBVTtRQUFPcEI7UUFBVWlCO1FBQVNyQyxVQUFVO1FBQWNzQztRQUFTRyxpQkFBaUJILFdBQVcsT0FBT0MsWUFBWTtRQUFPRyxnQkFBZ0JOO1FBQVFPLGtCQUFrQjtJQUFNO0FBQzdOO0FBRU8sU0FBU0MsWUFBWTNFLEdBQWEsRUFBRXdELE9BQWlCLEVBQUVDLFlBQW9CLEVBQUViLFNBQWtCO0lBQ3BHLE1BQU1jLFVBQVVGLFFBQVFHLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRS9CLFdBQVcsR0FBR0MsUUFBUSxDQUFDO0lBQ2hFLE1BQU0rQixVQUFVTCxRQUFRRyxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUNoRSxNQUFNZ0MsWUFBWU4sUUFBUUcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0IsV0FBVyxHQUFHQyxRQUFRLENBQUM7SUFDbEUsTUFBTWlDLGNBQWNQLFFBQVFHLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRS9CLFdBQVcsR0FBR0MsUUFBUSxDQUFDLGdCQUFnQixDQUFDOEIsRUFBRS9CLFdBQVcsR0FBR0MsUUFBUSxDQUFDO0lBQzlHLElBQUk0QixZQUFZLENBQUMsS0FBS0csWUFBWSxDQUFDLEtBQUtDLGNBQWMsQ0FBQyxHQUFHLE9BQU87SUFDakUsTUFBTUksT0FBT2pDLFVBQVVqQyxHQUFHLENBQUMwRCxRQUFRLEVBQUU7SUFDckMsTUFBTWYsY0FBYzNDLEdBQUcsQ0FBQzZELFFBQVEsSUFBSTtJQUNwQyxNQUFNTSxTQUFTL0IsWUFBWXBDLEdBQUcsQ0FBQzhELFVBQVU7SUFDekMsTUFBTWMsY0FBYzVFLEdBQUcsQ0FBQytELFlBQVksSUFBSTtJQUN4QyxNQUFNWixXQUFXeUIsZUFBZWxDLHNCQUFzQkMsYUFBYUM7SUFDbkUsT0FBTztRQUFFc0IsTUFBTUEsUUFBUTtRQUFJdkI7UUFBYXdCO1FBQVFJLFVBQVU7UUFBT3BCO1FBQVVpQixTQUFTWDtRQUFjMUIsVUFBVTtRQUFPMEMsZ0JBQWdCTjtRQUFRTyxrQkFBa0I7SUFBTTtBQUNySztBQUVPLFNBQVNHLGdCQUFnQjdFLEdBQWEsRUFBRXdELE9BQWlCLEVBQUVDLFlBQW9CLEVBQUVxQixZQUFvQixFQUFFbEMsU0FBa0I7SUFDOUgsTUFBTW1DLGFBQWF2QixRQUFRRyxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUNuRSxNQUFNa0QsZUFBZXhCLFFBQVFHLFNBQVMsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRS9CLFdBQVcsR0FBR0MsUUFBUSxDQUFDO0lBQ3JFLE1BQU0rQixVQUFVTCxRQUFRRyxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUNoRSxNQUFNZ0MsWUFBWU4sUUFBUUcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0IsV0FBVyxPQUFPLFlBQVkrQixFQUFFL0IsV0FBVyxHQUFHQyxRQUFRLENBQUM7SUFDbEcsTUFBTW1ELGNBQWN6QixRQUFRRyxTQUFTLENBQUNDLENBQUFBLElBQUtBLEVBQUUvQixXQUFXLE9BQU8sY0FBYytCLEVBQUUvQixXQUFXLEdBQUdDLFFBQVEsQ0FBQztJQUN0RyxNQUFNbUMsU0FBU1QsUUFBUUcsU0FBUyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0IsV0FBVyxPQUFPLGFBQWErQixFQUFFL0IsV0FBVyxHQUFHQyxRQUFRLENBQUM7SUFDaEcsSUFBSSxlQUFnQixDQUFDLEtBQUtrRCxpQkFBaUIsQ0FBQyxLQUFNbkIsWUFBWSxDQUFDLEtBQUtDLGNBQWMsQ0FBQyxHQUFHLE9BQU87SUFDN0YsTUFBTW9CLFVBQVVILGVBQWUsQ0FBQyxJQUFJL0UsR0FBRyxDQUFDK0UsV0FBVyxHQUFHL0UsR0FBRyxDQUFDZ0YsYUFBYTtJQUN2RSxNQUFNZCxPQUFPakMsVUFBVWlELFNBQVM7SUFDaEMsTUFBTXZDLGNBQWMzQyxHQUFHLENBQUM2RCxRQUFRLElBQUk7SUFDcEMsTUFBTXNCLFlBQVkvQyxZQUFZcEMsR0FBRyxDQUFDOEQsVUFBVTtJQUM1QyxNQUFNUyxXQUFXLENBQUNVLGdCQUFnQixDQUFDLElBQUlqRixHQUFHLENBQUNpRixZQUFZLEdBQUcsS0FBSSxLQUFNO0lBQ3BFLE1BQU1HLFlBQVliLFNBQVNjLFdBQVcsT0FBTyxRQUFRRixZQUFZTCxlQUFlSztJQUNoRixNQUFNaEMsV0FBV1Qsc0JBQXNCQyxhQUFhQztJQUNwRCxNQUFNMEMsYUFBYXJCLFdBQVcsQ0FBQyxJQUFJN0IsWUFBWXBDLEdBQUcsQ0FBQ2lFLE9BQU8sSUFBSUs7SUFDOUQsT0FBTztRQUFFSixNQUFNQSxRQUFRO1FBQUl2QjtRQUFhd0IsUUFBUWlCO1FBQVdiLFVBQVU7UUFBT3BCO1FBQVVpQixTQUFTWDtRQUFjMUIsVUFBVTtRQUFXc0MsU0FBU2lCO1FBQVlkLGlCQUFpQmMsY0FBYyxPQUFPaEIsWUFBYUMsWUFBWTtRQUFRRSxnQkFBZ0JVO1FBQVdULGtCQUFtQkgsWUFBWTtJQUFPO0FBQ2pTO0FBRU8sZUFBZWdCLFdBQVdDLEtBQThJLEVBQUVWLFlBQW9CLEVBQUVsQyxTQUFrQjtJQUN2TixNQUFNNkMsTUFBcUIsRUFBRTtJQUM3QixNQUFNbkMsVUFBVUQsT0FBT0MsT0FBTyxDQUFDa0M7SUFDL0IsS0FBSyxNQUFNLENBQUNFLE1BQU1DLEtBQUssSUFBSXJDLFFBQVM7UUFDbEMsSUFBSSxDQUFDcUMsTUFBTTtRQUNYLE1BQU0vRixPQUFPLE1BQU0rRixLQUFLL0YsSUFBSTtRQUM1QixNQUFNRSxPQUFPZSxTQUFTakI7UUFDdEIsSUFBSUUsS0FBS0ssTUFBTSxHQUFHLEdBQUc7UUFDckIsTUFBTSxFQUFFNEIsUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBR1IsZUFBZTFCO1FBQy9DLE1BQU0wRCxVQUFVMUQsSUFBSSxDQUFDa0MsVUFBVTtRQUMvQixJQUFLLElBQUk5QixJQUFJOEIsWUFBWSxHQUFHOUIsSUFBSUosS0FBS0ssTUFBTSxFQUFFRCxJQUFLO1lBQ2hELE1BQU1GLE1BQU1GLElBQUksQ0FBQ0ksRUFBRTtZQUNuQixJQUFJRixJQUFJRyxNQUFNLEdBQUcsR0FBRztZQUNwQixJQUFJSCxJQUFJNEYsS0FBSyxDQUFDQyxDQUFBQSxPQUFRLENBQUNBLFFBQVFBLEtBQUtqRixJQUFJLE9BQU8sS0FBSztZQUNwRCxJQUFJa0YsSUFBd0I7WUFDNUIsSUFBSS9ELGFBQWEsY0FBYztnQkFDN0IsSUFBSWdFLGVBQWU7Z0JBQ25CLElBQUlMLFNBQVMsc0JBQXNCSyxlQUFlO3FCQUM3QyxJQUFJTCxTQUFTLG1CQUFtQkssZUFBZTtnQkFDcERELElBQUl2QyxtQkFBbUJ2RCxLQUFLd0QsU0FBU3VDLGNBQWNuRDtZQUNyRCxPQUNLLElBQUliLGFBQWEsT0FBTytELElBQUluQixZQUFZM0UsS0FBS3dELFNBQVMsT0FBT1o7aUJBQzdELElBQUliLGFBQWEsV0FBVytELElBQUlqQixnQkFBZ0I3RSxLQUFLd0QsU0FBUyxXQUFXc0IsY0FBY2xDO1lBQzVGLElBQUlrRCxLQUFLQSxFQUFFNUIsSUFBSSxJQUFJNEIsRUFBRTNCLE1BQU0sS0FBSyxHQUFHc0IsSUFBSW5GLElBQUksQ0FBQ3dGO1FBQzlDO0lBQ0Y7SUFDQUwsSUFBSU8sSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVoQyxJQUFJLENBQUNpQyxhQUFhLENBQUNGLEVBQUUvQixJQUFJO0lBQzlDLE9BQU91QjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvc3RhdGVtZW50cy9wYXJzZXIudHM/MzlkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZXRlY3RlZFByb3ZpZGVyLCBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHlwZXMnXG5cbi8vIENTViBwYXJzaW5nIHdpdGggZGVsaW1pdGVyIGRldGVjdGlvbiBhbmQgQk9NIGhhbmRsaW5nXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDU1ZXaXRoRGVsaW1pdGVyKHRleHQ6IHN0cmluZywgZGVsaW1pdGVyOiBzdHJpbmcpOiBzdHJpbmdbXVtdIHtcbiAgY29uc3Qgcm93czogc3RyaW5nW11bXSA9IFtdXG4gIGxldCBjdXIgPSAnJ1xuICBsZXQgcm93OiBzdHJpbmdbXSA9IFtdXG4gIGxldCBpblF1b3RlcyA9IGZhbHNlXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IHRleHRbaV1cbiAgICBjb25zdCBuZXh0ID0gdGV4dFtpICsgMV1cblxuICAgIGlmIChpblF1b3Rlcykge1xuICAgICAgaWYgKGMgPT09ICdcIicgJiYgbmV4dCA9PT0gJ1wiJykge1xuICAgICAgICBjdXIgKz0gJ1wiJ1xuICAgICAgICBpKytcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICBpblF1b3RlcyA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXIgKz0gY1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICBpblF1b3RlcyA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICAgIHJvdy5wdXNoKGN1cilcbiAgICAgICAgY3VyID0gJydcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1xcbicpIHtcbiAgICAgICAgcm93LnB1c2goY3VyKVxuICAgICAgICByb3dzLnB1c2gocm93KVxuICAgICAgICByb3cgPSBbXVxuICAgICAgICBjdXIgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChjID09PSAnXFxyJykge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ciArPSBjXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1ci5sZW5ndGggPiAwIHx8IHJvdy5sZW5ndGggPiAwKSB7XG4gICAgcm93LnB1c2goY3VyKVxuICAgIHJvd3MucHVzaChyb3cpXG4gIH1cblxuICAvLyBDbGVhbiBCT00gYW5kIHRyaW0gY2VsbHNcbiAgaWYgKHJvd3MubGVuZ3RoICYmIHJvd3NbMF0ubGVuZ3RoKSB7XG4gICAgcm93c1swXVswXSA9IHJvd3NbMF1bMF0ucmVwbGFjZSgvXlxcdWZlZmYvLCAnJylcbiAgfVxuICBmb3IgKGxldCByID0gMDsgciA8IHJvd3MubGVuZ3RoOyByKyspIHtcbiAgICByb3dzW3JdID0gcm93c1tyXS5tYXAodiA9PiAodiA9PSBudWxsID8gJycgOiBTdHJpbmcodikudHJpbSgpKSlcbiAgfVxuICByZXR1cm4gcm93c1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDU1YodGV4dDogc3RyaW5nKTogc3RyaW5nW11bXSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbJywnLCAnOycsICdcXHQnXVxuICBsZXQgYmVzdDogc3RyaW5nW11bXSB8IG51bGwgPSBudWxsXG4gIGxldCBiZXN0U2NvcmUgPSAtMVxuXG4gIGZvciAoY29uc3QgZCBvZiBjYW5kaWRhdGVzKSB7XG4gICAgY29uc3Qgcm93cyA9IHBhcnNlQ1NWV2l0aERlbGltaXRlcih0ZXh0LCBkKVxuICAgIGxldCBjb3VudCA9IDAsIGNvbHMgPSAwXG4gICAgZm9yIChjb25zdCByIG9mIHJvd3MpIHtcbiAgICAgIGNvbnN0IG5vbkVtcHR5ID0gci5maWx0ZXIoeCA9PiB4ICYmIHgudHJpbSgpICE9PSAnJykubGVuZ3RoXG4gICAgICBpZiAobm9uRW1wdHkgPiAxKSB7XG4gICAgICAgIGNvbHMgKz0gci5sZW5ndGhcbiAgICAgICAgY291bnQrK1xuICAgICAgfVxuICAgICAgaWYgKGNvdW50ID49IDUpIGJyZWFrXG4gICAgfVxuICAgIGNvbnN0IHNjb3JlID0gY291bnQgPyBjb2xzIC8gY291bnQgOiAwXG4gICAgaWYgKHNjb3JlID4gYmVzdFNjb3JlKSB7XG4gICAgICBiZXN0U2NvcmUgPSBzY29yZVxuICAgICAgYmVzdCA9IHJvd3NcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmVzdCB8fCBbW11dXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RQcm92aWRlcihyb3dzOiBzdHJpbmdbXVtdKTogRGV0ZWN0ZWRQcm92aWRlciB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4oNSwgcm93cy5sZW5ndGgpOyBpKyspIHtcbiAgICBjb25zdCBoZWFkZXJTdHIgPSByb3dzW2ldLmpvaW4oJyAnKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKFxuICAgICAgaGVhZGVyU3RyLmluY2x1ZGVzKCdkYXRlb3AnKSB8fCBoZWFkZXJTdHIuaW5jbHVkZXMoJ2RhdGV2YWwnKSB8fFxuICAgICAgaGVhZGVyU3RyLmluY2x1ZGVzKCdjYXRlZ29yeXBhcmVudCcpIHx8IGhlYWRlclN0ci5pbmNsdWRlcygnYWNjb3VudGxhYmVsJylcbiAgICApIHtcbiAgICAgIHJldHVybiB7IHByb3ZpZGVyOiAnYm91cnNvcmFtYScsIGhlYWRlclJvdzogaSB9XG4gICAgfVxuICAgIGlmIChcbiAgICAgIGhlYWRlclN0ci5pbmNsdWRlcygnZGF0ZSBvcGVyYXRpb24nKSB8fCBoZWFkZXJTdHIuaW5jbHVkZXMoJ2NhdGVnb3JpZSBvcGVyYXRpb24nKSB8fFxuICAgICAgaGVhZGVyU3RyLmluY2x1ZGVzKCdsaWJlbGxlIG9wZXJhdGlvbicpIHx8IGhlYWRlclN0ci5pbmNsdWRlcygnbW9udGFudCBvcGVyYXRpb24nKVxuICAgICkge1xuICAgICAgcmV0dXJuIHsgcHJvdmlkZXI6ICdibnAnLCBoZWFkZXJSb3c6IGkgfVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBoZWFkZXJTdHIuaW5jbHVkZXMoJ3N0YXJ0ZWQgZGF0ZScpIHx8IGhlYWRlclN0ci5pbmNsdWRlcygnY29tcGxldGVkIGRhdGUnKSB8fFxuICAgICAgKGhlYWRlclN0ci5pbmNsdWRlcygndHlwZScpICYmIGhlYWRlclN0ci5pbmNsdWRlcygncHJvZHVjdCcpICYmIGhlYWRlclN0ci5pbmNsdWRlcygnYW1vdW50JykpXG4gICAgKSB7XG4gICAgICByZXR1cm4geyBwcm92aWRlcjogJ3Jldm9sdXQnLCBoZWFkZXJSb3c6IGkgfVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcm92aWRlcjogJ3Vua25vd24nLCBoZWFkZXJSb3c6IDAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHI6IHN0cmluZywgcHJvdmlkZXI6IFRyYW5zYWN0aW9uWydwcm92aWRlciddKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghZGF0ZVN0cikgcmV0dXJuIG51bGxcbiAgaWYgKHByb3ZpZGVyID09PSAnYm91cnNvcmFtYScpIHtcbiAgICBjb25zdCBtYXRjaCA9IGRhdGVTdHIubWF0Y2goLyhcXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pLylcbiAgICBpZiAobWF0Y2gpIHJldHVybiBgJHttYXRjaFsxXX0tJHttYXRjaFsyXX0tJHttYXRjaFszXX1gXG4gIH0gZWxzZSBpZiAocHJvdmlkZXIgPT09ICdyZXZvbHV0Jykge1xuICAgIGNvbnN0IG1hdGNoID0gZGF0ZVN0ci5tYXRjaCgvKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSkvKVxuICAgIGlmIChtYXRjaCkgcmV0dXJuIGAke21hdGNoWzFdfS0ke21hdGNoWzJdfS0ke21hdGNoWzNdfWBcbiAgfSBlbHNlIGlmIChwcm92aWRlciA9PT0gJ2JucCcpIHtcbiAgICBjb25zdCBtYXRjaCA9IGRhdGVTdHIubWF0Y2goLyhcXGR7Mn0pLShcXGR7Mn0pLShcXGR7NH0pLylcbiAgICBpZiAobWF0Y2gpIHJldHVybiBgJHttYXRjaFszXX0tJHttYXRjaFsyXX0tJHttYXRjaFsxXX1gXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2ggPSBkYXRlU3RyLm1hdGNoKC8oXFxkezJ9KVxcLyhcXGR7Mn0pXFwvKFxcZHs0fSkvKVxuICAgIGlmIChtYXRjaCkgcmV0dXJuIGAke21hdGNoWzNdfS0ke21hdGNoWzJdfS0ke21hdGNoWzFdfWBcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBbW91bnQodjogdW5rbm93bik6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHJldHVybiB2XG4gIGlmICh2ID09IG51bGwpIHJldHVybiAwXG4gIGxldCBzID0gU3RyaW5nKHYpLnRyaW0oKVxuICBpZiAoIXMpIHJldHVybiAwXG4gIHMgPSBzLnJlcGxhY2UoL1xccy9nLCAnJylcbiAgaWYgKHMuaW5jbHVkZXMoJywnKSkge1xuICAgIGlmIChzLmluZGV4T2YoJy4nKSA8IHMuaW5kZXhPZignLCcpKSB7XG4gICAgICBzID0gcy5yZXBsYWNlKC9cXC4vZywgJycpLnJlcGxhY2UoJywnLCAnLicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpXG4gICAgfVxuICB9XG4gIHMgPSBzLnJlcGxhY2UoL1teXFxkLi1dL2csICcnKVxuICBjb25zdCBuID0gcGFyc2VGbG9hdChzKVxuICByZXR1cm4gaXNOYU4obikgPyAwIDogblxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2F0ZWdvcml6ZVRyYW5zYWN0aW9uKGRlc2NyaXB0aW9uOiBzdHJpbmcsIHJ1bGVzVGV4dD86IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGRlc2MgPSAoZGVzY3JpcHRpb24gfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgY2F0ZWdvcmllczogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge1xuICAgICdUcmFuc3BvcnQnOiBbJ3NuY2YnLCAncmF0cCcsICd1YmVyJywgJ3RheGknLCAnbWV0cm8nLCAnYnVzJywgJ3RyYWluJ10sXG4gICAgJ0UtY29tbWVyY2UnOiBbJ2FtYXpvbicsICdjZGlzY291bnQnLCAnZm5hYycsICdlYmF5JywgJ2FsaWV4cHJlc3MnXSxcbiAgICAnRm9vZCAmIFJlc3RhdXJhbnRzJzogWydjYXJyZWZvdXInLCAnZnJhbnByaXgnLCAnbW9ub3ByaXgnLCAnYXVjaGFuJywgJ3Jlc3RhdXJhbnQnLCAnY2FmZScsICdib3VsYW5nZXJpZSddLFxuICAgICdVdGlsaXRpZXMnOiBbJ2VkZicsICdvcmFuZ2UnLCAnc2ZyJywgJ2ZyZWUnLCAnYm91eWd1ZXMnLCAnaW50ZXJuZXQnLCAnbW9iaWxlJ10sXG4gICAgJ0hlYWx0aCc6IFsncGhhcm1hY3knLCAncGhhcm1hY2llJywgJ2RvY3RvcicsICdkb2N0ZXVyJywgJ21lZGljYWwnLCAnaG9waXRhbCddLFxuICAgICdBY2NvbW1vZGF0aW9uJzogWydhaXJibmInLCAnaG90ZWwnLCAnYm9va2luZycsICdsb3llcicsICdyZW50J10sXG4gICAgJ0VudGVydGFpbm1lbnQnOiBbJ2NpbmVtYScsICduZXRmbGl4JywgJ3Nwb3RpZnknLCAnc3RlYW0nLCAncGxheXN0YXRpb24nLCAneGJveCddXG4gIH1cbiAgaWYgKHJ1bGVzVGV4dCkge1xuICAgIGNvbnN0IGxpbmVzID0gcnVsZXNUZXh0LnNwbGl0KCdcXG4nKVxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgY29uc3QgW2tleXdvcmQsIGNhdGVnb3J5XSA9IGxpbmUuc3BsaXQoJz0nKS5tYXAocyA9PiBzPy50cmltKCkgPz8gJycpXG4gICAgICBpZiAoa2V5d29yZCAmJiBjYXRlZ29yeSAmJiBkZXNjLmluY2x1ZGVzKGtleXdvcmQudG9Mb3dlckNhc2UoKSkpIHJldHVybiBjYXRlZ29yeVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtjYXRlZ29yeSwga2V5d29yZHNdIG9mIE9iamVjdC5lbnRyaWVzKGNhdGVnb3JpZXMpKSB7XG4gICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIGtleXdvcmRzKSB7XG4gICAgICBpZiAoZGVzYy5pbmNsdWRlcyhrZXl3b3JkKSkgcmV0dXJuIGNhdGVnb3J5XG4gICAgfVxuICB9XG4gIHJldHVybiAnT3RoZXInXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJvdXJzb3JhbWFSb3cocm93OiBzdHJpbmdbXSwgaGVhZGVyczogc3RyaW5nW10sIGFjY291bnRMYWJlbDogc3RyaW5nLCBydWxlc1RleHQ/OiBzdHJpbmcpOiBUcmFuc2FjdGlvbiB8IG51bGwge1xuICBjb25zdCBkYXRlSWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2RhdGVvcCcpKVxuICBjb25zdCBkZXNjSWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLnRvTG93ZXJDYXNlKCkgPT09ICdsYWJlbCcgfHwgaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdsYWJlbCcpKVxuICBjb25zdCBhbW91bnRJZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGgudG9Mb3dlckNhc2UoKSA9PT0gJ2Ftb3VudCcpXG4gIGNvbnN0IGNhdGVnb3J5SWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLnRvTG93ZXJDYXNlKCkgPT09ICdjYXRlZ29yeXBhcmVudCcgfHwgaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjYXRlZ29yeXBhcmVudCcpKVxuICBjb25zdCBhY2NvdW50SWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLnRvTG93ZXJDYXNlKCkgPT09ICdhY2NvdW50bGFiZWwnIHx8IGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYWNjb3VudGxhYmVsJykpXG4gIGNvbnN0IGJhbElkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC50b0xvd2VyQ2FzZSgpID09PSAnYWNjb3VudGJhbGFuY2UnIHx8IGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYWNjb3VudGJhbGFuY2UnKSlcbiAgaWYgKGRhdGVJZHggPT09IC0xIHx8IGRlc2NJZHggPT09IC0xIHx8IGFtb3VudElkeCA9PT0gLTEpIHJldHVybiBudWxsXG4gIGNvbnN0IGRhdGUgPSBwYXJzZURhdGUocm93W2RhdGVJZHhdLCAnYm91cnNvcmFtYScpXG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gcm93W2Rlc2NJZHhdIHx8ICcnXG4gIGNvbnN0IGFtb3VudCA9IHBhcnNlQW1vdW50KHJvd1thbW91bnRJZHhdKVxuICBjb25zdCBjYXRlZ29yeSA9IHJvd1tjYXRlZ29yeUlkeF0gfHwgY2F0ZWdvcml6ZVRyYW5zYWN0aW9uKGRlc2NyaXB0aW9uLCBydWxlc1RleHQpXG4gIGNvbnN0IGFjY291bnQgPSBhY2NvdW50SWR4ICE9PSAtMSA/IChyb3dbYWNjb3VudElkeF0gfHwgYWNjb3VudExhYmVsKSA6IGFjY291bnRMYWJlbFxuICBjb25zdCBiYWxhbmNlID0gYmFsSWR4ICE9PSAtMSA/IHBhcnNlQW1vdW50KHJvd1tiYWxJZHhdKSA6IHVuZGVmaW5lZFxuICByZXR1cm4geyBkYXRlOiBkYXRlIHx8ICcnLCBkZXNjcmlwdGlvbiwgYW1vdW50LCBjdXJyZW5jeTogJ0VVUicsIGNhdGVnb3J5LCBhY2NvdW50LCBwcm92aWRlcjogJ2JvdXJzb3JhbWEnLCBiYWxhbmNlLCBiYWxhbmNlQ3VycmVuY3k6IGJhbGFuY2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6ICdFVVInLCBvcmlnaW5hbEFtb3VudDogYW1vdW50LCBvcmlnaW5hbEN1cnJlbmN5OiAnRVVSJyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJOUFJvdyhyb3c6IHN0cmluZ1tdLCBoZWFkZXJzOiBzdHJpbmdbXSwgYWNjb3VudExhYmVsOiBzdHJpbmcsIHJ1bGVzVGV4dD86IHN0cmluZyk6IFRyYW5zYWN0aW9uIHwgbnVsbCB7XG4gIGNvbnN0IGRhdGVJZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnZGF0ZScpKVxuICBjb25zdCBkZXNjSWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2xpYmVsbGUnKSlcbiAgY29uc3QgYW1vdW50SWR4ID0gaGVhZGVycy5maW5kSW5kZXgoaCA9PiBoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ21vbnRhbnQnKSlcbiAgY29uc3QgY2F0ZWdvcnlJZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnY2F0ZWdvcmllJykgJiYgIWgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnc291cycpKVxuICBpZiAoZGF0ZUlkeCA9PT0gLTEgfHwgZGVzY0lkeCA9PT0gLTEgfHwgYW1vdW50SWR4ID09PSAtMSkgcmV0dXJuIG51bGxcbiAgY29uc3QgZGF0ZSA9IHBhcnNlRGF0ZShyb3dbZGF0ZUlkeF0sICdibnAnKVxuICBjb25zdCBkZXNjcmlwdGlvbiA9IHJvd1tkZXNjSWR4XSB8fCAnJ1xuICBjb25zdCBhbW91bnQgPSBwYXJzZUFtb3VudChyb3dbYW1vdW50SWR4XSlcbiAgY29uc3QgYm5wQ2F0ZWdvcnkgPSByb3dbY2F0ZWdvcnlJZHhdIHx8ICcnXG4gIGNvbnN0IGNhdGVnb3J5ID0gYm5wQ2F0ZWdvcnkgfHwgY2F0ZWdvcml6ZVRyYW5zYWN0aW9uKGRlc2NyaXB0aW9uLCBydWxlc1RleHQpXG4gIHJldHVybiB7IGRhdGU6IGRhdGUgfHwgJycsIGRlc2NyaXB0aW9uLCBhbW91bnQsIGN1cnJlbmN5OiAnRVVSJywgY2F0ZWdvcnksIGFjY291bnQ6IGFjY291bnRMYWJlbCwgcHJvdmlkZXI6ICdibnAnLCBvcmlnaW5hbEFtb3VudDogYW1vdW50LCBvcmlnaW5hbEN1cnJlbmN5OiAnRVVSJyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJldm9sdXRSb3cocm93OiBzdHJpbmdbXSwgaGVhZGVyczogc3RyaW5nW10sIGFjY291bnRMYWJlbDogc3RyaW5nLCBnYnBUb0V1clJhdGU6IG51bWJlciwgcnVsZXNUZXh0Pzogc3RyaW5nKTogVHJhbnNhY3Rpb24gfCBudWxsIHtcbiAgY29uc3Qgc3RhcnRlZElkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdzdGFydGVkJykpXG4gIGNvbnN0IGNvbXBsZXRlZElkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdjb21wbGV0ZWQnKSlcbiAgY29uc3QgZGVzY0lkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdkZXNjcmlwdGlvbicpKVxuICBjb25zdCBhbW91bnRJZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGgudG9Mb3dlckNhc2UoKSA9PT0gJ2Ftb3VudCcgfHwgaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdhbW91bnQnKSlcbiAgY29uc3QgY3VycmVuY3lJZHggPSBoZWFkZXJzLmZpbmRJbmRleChoID0+IGgudG9Mb3dlckNhc2UoKSA9PT0gJ2N1cnJlbmN5JyB8fCBoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2N1cnJlbmN5JykpXG4gIGNvbnN0IGJhbElkeCA9IGhlYWRlcnMuZmluZEluZGV4KGggPT4gaC50b0xvd2VyQ2FzZSgpID09PSAnYmFsYW5jZScgfHwgaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdiYWxhbmNlJykpXG4gIGlmICgoc3RhcnRlZElkeCA9PT0gLTEgJiYgY29tcGxldGVkSWR4ID09PSAtMSkgfHwgZGVzY0lkeCA9PT0gLTEgfHwgYW1vdW50SWR4ID09PSAtMSkgcmV0dXJuIG51bGxcbiAgY29uc3QgZGF0ZVJhdyA9IHN0YXJ0ZWRJZHggIT09IC0xID8gcm93W3N0YXJ0ZWRJZHhdIDogcm93W2NvbXBsZXRlZElkeF1cbiAgY29uc3QgZGF0ZSA9IHBhcnNlRGF0ZShkYXRlUmF3LCAncmV2b2x1dCcpXG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gcm93W2Rlc2NJZHhdIHx8ICcnXG4gIGNvbnN0IGFtb3VudFJhdyA9IHBhcnNlQW1vdW50KHJvd1thbW91bnRJZHhdKVxuICBjb25zdCBjdXJyZW5jeSA9IChjdXJyZW5jeUlkeCAhPT0gLTEgPyByb3dbY3VycmVuY3lJZHhdIDogJ0VVUicpIHx8ICdFVVInXG4gIGNvbnN0IGFtb3VudEVVUiA9IGN1cnJlbmN5LnRvVXBwZXJDYXNlKCkgPT09ICdHQlAnID8gYW1vdW50UmF3ICogZ2JwVG9FdXJSYXRlIDogYW1vdW50UmF3XG4gIGNvbnN0IGNhdGVnb3J5ID0gY2F0ZWdvcml6ZVRyYW5zYWN0aW9uKGRlc2NyaXB0aW9uLCBydWxlc1RleHQpXG4gIGNvbnN0IHJhd0JhbGFuY2UgPSBiYWxJZHggIT09IC0xID8gcGFyc2VBbW91bnQocm93W2JhbElkeF0pIDogdW5kZWZpbmVkXG4gIHJldHVybiB7IGRhdGU6IGRhdGUgfHwgJycsIGRlc2NyaXB0aW9uLCBhbW91bnQ6IGFtb3VudEVVUiwgY3VycmVuY3k6ICdFVVInLCBjYXRlZ29yeSwgYWNjb3VudDogYWNjb3VudExhYmVsLCBwcm92aWRlcjogJ3Jldm9sdXQnLCBiYWxhbmNlOiByYXdCYWxhbmNlLCBiYWxhbmNlQ3VycmVuY3k6IHJhd0JhbGFuY2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IChjdXJyZW5jeSB8fCAnR0JQJyksIG9yaWdpbmFsQW1vdW50OiBhbW91bnRSYXcsIG9yaWdpbmFsQ3VycmVuY3k6IChjdXJyZW5jeSB8fCAnR0JQJykgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VGaWxlcyhmaWxlczogeyBib3Vyc29yYW1hUGVyc29uYWw/OiBGaWxlIHwgbnVsbDsgYm91cnNvcmFtYUpvaW50PzogRmlsZSB8IG51bGw7IGJvdXJzb3JhbWE/OiBGaWxlIHwgbnVsbDsgYm5wPzogRmlsZSB8IG51bGw7IHJldm9sdXQ/OiBGaWxlIHwgbnVsbCB9LCBnYnBUb0V1clJhdGU6IG51bWJlciwgcnVsZXNUZXh0Pzogc3RyaW5nKTogUHJvbWlzZTxUcmFuc2FjdGlvbltdPiB7XG4gIGNvbnN0IGFsbDogVHJhbnNhY3Rpb25bXSA9IFtdXG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhmaWxlcykgYXMgW2tleW9mIHR5cGVvZiBmaWxlcywgRmlsZSB8IG51bGwgfCB1bmRlZmluZWRdW11cbiAgZm9yIChjb25zdCBbYmFuaywgZmlsZV0gb2YgZW50cmllcykge1xuICAgIGlmICghZmlsZSkgY29udGludWVcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgZmlsZS50ZXh0KClcbiAgICBjb25zdCByb3dzID0gcGFyc2VDU1YodGV4dClcbiAgICBpZiAocm93cy5sZW5ndGggPCAyKSBjb250aW51ZVxuICAgIGNvbnN0IHsgcHJvdmlkZXIsIGhlYWRlclJvdyB9ID0gZGV0ZWN0UHJvdmlkZXIocm93cylcbiAgICBjb25zdCBoZWFkZXJzID0gcm93c1toZWFkZXJSb3ddXG4gICAgZm9yIChsZXQgaSA9IGhlYWRlclJvdyArIDE7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByb3cgPSByb3dzW2ldXG4gICAgICBpZiAocm93Lmxlbmd0aCA8IDMpIGNvbnRpbnVlXG4gICAgICBpZiAocm93LmV2ZXJ5KGNlbGwgPT4gIWNlbGwgfHwgY2VsbC50cmltKCkgPT09ICcnKSkgY29udGludWVcbiAgICAgIGxldCB0OiBUcmFuc2FjdGlvbiB8IG51bGwgPSBudWxsXG4gICAgICBpZiAocHJvdmlkZXIgPT09ICdib3Vyc29yYW1hJykge1xuICAgICAgICBsZXQgZGVmYXVsdExhYmVsID0gJ0JvdXJzb3JhbWEnXG4gICAgICAgIGlmIChiYW5rID09PSAnYm91cnNvcmFtYVBlcnNvbmFsJykgZGVmYXVsdExhYmVsID0gJ0JvdXJzb0JhbmsnXG4gICAgICAgIGVsc2UgaWYgKGJhbmsgPT09ICdib3Vyc29yYW1hSm9pbnQnKSBkZWZhdWx0TGFiZWwgPSAnQm91cnNvQmFuayAoam9pbnQpJ1xuICAgICAgICB0ID0gcGFyc2VCb3Vyc29yYW1hUm93KHJvdywgaGVhZGVycywgZGVmYXVsdExhYmVsLCBydWxlc1RleHQpXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcm92aWRlciA9PT0gJ2JucCcpIHQgPSBwYXJzZUJOUFJvdyhyb3csIGhlYWRlcnMsICdCTlAnLCBydWxlc1RleHQpXG4gICAgICBlbHNlIGlmIChwcm92aWRlciA9PT0gJ3Jldm9sdXQnKSB0ID0gcGFyc2VSZXZvbHV0Um93KHJvdywgaGVhZGVycywgJ1Jldm9sdXQnLCBnYnBUb0V1clJhdGUsIHJ1bGVzVGV4dClcbiAgICAgIGlmICh0ICYmIHQuZGF0ZSAmJiB0LmFtb3VudCAhPT0gMCkgYWxsLnB1c2godClcbiAgICB9XG4gIH1cbiAgYWxsLnNvcnQoKGEsIGIpID0+IGIuZGF0ZS5sb2NhbGVDb21wYXJlKGEuZGF0ZSkpXG4gIHJldHVybiBhbGxcbn1cbiJdLCJuYW1lcyI6WyJwYXJzZUNTVldpdGhEZWxpbWl0ZXIiLCJ0ZXh0IiwiZGVsaW1pdGVyIiwicm93cyIsImN1ciIsInJvdyIsImluUXVvdGVzIiwiaSIsImxlbmd0aCIsImMiLCJuZXh0IiwicHVzaCIsInJlcGxhY2UiLCJyIiwibWFwIiwidiIsIlN0cmluZyIsInRyaW0iLCJwYXJzZUNTViIsImNhbmRpZGF0ZXMiLCJiZXN0IiwiYmVzdFNjb3JlIiwiZCIsImNvdW50IiwiY29scyIsIm5vbkVtcHR5IiwiZmlsdGVyIiwieCIsInNjb3JlIiwiZGV0ZWN0UHJvdmlkZXIiLCJNYXRoIiwibWluIiwiaGVhZGVyU3RyIiwiam9pbiIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJwcm92aWRlciIsImhlYWRlclJvdyIsInBhcnNlRGF0ZSIsImRhdGVTdHIiLCJtYXRjaCIsInBhcnNlQW1vdW50IiwicyIsImluZGV4T2YiLCJuIiwicGFyc2VGbG9hdCIsImlzTmFOIiwiY2F0ZWdvcml6ZVRyYW5zYWN0aW9uIiwiZGVzY3JpcHRpb24iLCJydWxlc1RleHQiLCJkZXNjIiwiY2F0ZWdvcmllcyIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwia2V5d29yZCIsImNhdGVnb3J5Iiwia2V5d29yZHMiLCJPYmplY3QiLCJlbnRyaWVzIiwicGFyc2VCb3Vyc29yYW1hUm93IiwiaGVhZGVycyIsImFjY291bnRMYWJlbCIsImRhdGVJZHgiLCJmaW5kSW5kZXgiLCJoIiwiZGVzY0lkeCIsImFtb3VudElkeCIsImNhdGVnb3J5SWR4IiwiYWNjb3VudElkeCIsImJhbElkeCIsImRhdGUiLCJhbW91bnQiLCJhY2NvdW50IiwiYmFsYW5jZSIsInVuZGVmaW5lZCIsImN1cnJlbmN5IiwiYmFsYW5jZUN1cnJlbmN5Iiwib3JpZ2luYWxBbW91bnQiLCJvcmlnaW5hbEN1cnJlbmN5IiwicGFyc2VCTlBSb3ciLCJibnBDYXRlZ29yeSIsInBhcnNlUmV2b2x1dFJvdyIsImdicFRvRXVyUmF0ZSIsInN0YXJ0ZWRJZHgiLCJjb21wbGV0ZWRJZHgiLCJjdXJyZW5jeUlkeCIsImRhdGVSYXciLCJhbW91bnRSYXciLCJhbW91bnRFVVIiLCJ0b1VwcGVyQ2FzZSIsInJhd0JhbGFuY2UiLCJwYXJzZUZpbGVzIiwiZmlsZXMiLCJhbGwiLCJiYW5rIiwiZmlsZSIsImV2ZXJ5IiwiY2VsbCIsInQiLCJkZWZhdWx0TGFiZWwiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/statements/parser.ts\n"));

/***/ })

});